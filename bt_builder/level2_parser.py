from bt_instruction2bt_mapper.bt_tools import *
from bt_disambiguator.disambiguator import *
from bt_language_parser.parser import *
import llm.llm as llm


def add_synonyms_to_bt_library(bt_desc):
    pass


def get_level2_bt_from_bt_desc_prompt(bt_desc):
    prompt = f"""
According to the intent described in the quotes after "desc: ", \
one of the behavior tree nodes available below is selected as the answer to generate.

The available behavior tree nodes are:
{get_bts_info_prompt()}

Example:
desc: "ask for help"
request_help
desc: "是否存在危险物品或障碍物"
envs_safety


Require:
- only print behavior tree node names
- If no behavior tree node matching this condition is found in the intent, return "None"

desc: "{bt_desc}"
    """
    return prompt


def get_level2_generate_prompt(sent):
    prompt = f"""
Please generate a 'regular expression' for the sentence using a generalized pattern. \
Each behavior intent, often represented by a verb or a verb phrase, should be wrapped in parentheses. \
The verb phrases could be separated by commas or the phrase 'and then', \
and the final intent might contain a destination introduced by 'to'.

The regular expression pattern should look like this: "(.*?), (.*?), and then (.*?) (to .*?)". \
The commas and 'and then' serve as separators between different behavior intents, and 'to' introduces the destination.

For instance, for a sentence like \
"Check the safety of the environment, grab the package, and then move it to the target location.", \
the generated regular expression should be \
"(.*?), (.*?), and then (.*?) (to .*?)".

Require:
- Generate the 'regular expression' results directly, no colons required.
- do not print quotes

sentence "{sent}"
    """
    return prompt


def create_level2_bt_list(sent):
    """
    :param sent: "流程"描述级语言
    :return: 行为树节点列表
    """
    # TODO: 1 读取 level2_generator_rules.xml。获取相应 正则表达式 代码，并且生成具体的行为树。
    filename = dir_root + "bt_builder/level2_generator_rules.xml"
    tree = ET.parse(filename)
    root = tree.getroot()
    rules = root.findall("rule")
    bt_list = []
    bt_desc_list = []
    status_info = None
    for rule in rules:
        pattern = rule.find("pattern").text
        match = re.search(pattern, sent, re.IGNORECASE)
        if match:
            for part in match.groups():
                bt_desc_list.append(part)
            status_info = "SUCCESS"
            break
    # TODO: 2 所有已有规则都不匹配。调用大模型，生成新的规则，并且保存到 level2_generator_rules.xml中
    if status_info != "SUCCESS":
        # TODO: 2.1 获取级别2语言的正则表达式提示词，然后调用 ChatGPT 生成正则表达式
        prompt = get_level2_generate_prompt(sent)
        result_pattern = None
        for i in range(5):
            result_pattern = llm.get_completion(prompt, temperature=0, model="gpt-3.5-turbo")
            # TODO: 2.2 检验该正则表达式是否可以正确匹配 sent。如果不能就重新生成
            # NOTE: 这里可以进行prompt的不断优化，让答案更加符合需求
            match = re.search(result_pattern, sent, re.IGNORECASE)
            if match:
                for part in match.groups():
                    bt_desc_list.append(part)
                break
        # TODO: 2.3 将该正则表达式添加到文件中
        with open(filename, 'r') as file:
            lines = file.readlines()
        # 找到最后一个非空行的索引
        last_non_empty_line = next((i for i, line in reversed(list(enumerate(lines))) if line.strip()), None)
        # 如果找到了非空行，那么就将其删除
        if last_non_empty_line is not None:
            del lines[last_non_empty_line]
        # 写入新的行
        lines.append("    <rule>\n")
        lines.append("          <pattern>" + result_pattern + "</pattern>\n")
        lines.append("          <demo>" + sent + "</demo>\n")
        lines.append("    </rule>\n")
        lines.append("</root>\n")
        # 将新的内容写入文件
        with open(filename, 'w') as file:
            file.writelines(lines)
    # TODO: 3 根据 bt_desc_list 得到对应的 bt节点，如果匹配不到，则调用歧义消解模块
    print("bt_desc_list: " + str(bt_desc_list))
    for bt_desc in bt_desc_list:
        node_name, node_type = find_bt(bt_desc)
        if node_name is not None and node_type != -1:
            bt_info = {"name": node_name, "type": node_type}
            bt_list.append(bt_info)
        else:
            # TODO： 4 如果找不到，调用大模型，匹配 bt_desc_list 对应的行为树节点，并且加入到文件中
            prompt = get_level2_bt_from_bt_desc_prompt(bt_desc)
            result = llm.get_completion(prompt)
            print("llm for bt_desc to bt    bt_desc: " + bt_desc + "  result: " + result)
            # 判断是否生成，如果有相应的行为树节点，则以同义词存放到相应节点文件中
            if result != "None":
                node_name, node_type = find_bt(result)
                if node_name is not None and node_type != -1:
                    bt_info = {"name": node_name, "type": node_type}
                    bt_list.append(bt_info)
                else:
                    print("ERROR: Answer generated by LLM is not a Behavior Tree node")
            else:
                return None, "ERROR: There is no corresponding behavior tree node, \
    and further decomposition may be required. '" + bt_desc + "' !!"
    return bt_list, "SUCCESS"
